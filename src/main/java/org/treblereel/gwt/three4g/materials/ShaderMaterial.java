package org.treblereel.gwt.three4g.materials;

import jsinterop.annotations.JsConstructor;
import jsinterop.annotations.JsProperty;
import jsinterop.annotations.JsType;
import jsinterop.base.JsPropertyMap;
import org.treblereel.gwt.three4g.materials.parameters.ShaderMaterialParameters;
import org.treblereel.gwt.three4g.renderers.webgl.WebGLProgram;

/**
 * A material rendered with custom shaders. A shader is a small program written in GLSL that runs on the GPU. You may want to use a custom shader if you need to:
 * implement an effect not included with any of the built-in materials
 * combine many objects into a single Geometry or BufferGeometry in order to improve performance
 *
 * @author Dmitrii Tikhomirov <chani@me.com>
 * Created by treblereel on 4/12/18.
 */
@JsType(isNative = true, namespace = "THREE")
public class ShaderMaterial extends Material {

    private ShaderMaterialExtensions extensions;

    /**
     * Define whether the material color is affected by global fog settings; true to pass fog uniforms to the shader.
     * Default is false.
     */
    public boolean fog;

    /**
     * Fragment shader GLSL code. This is the actual code for the shader. In the example above, the vertexShader
     * and fragmentShader code is extracted from the DOM; it could be passed as a string directly or loaded via
     * AJAX instead.
     */
    public String fragmentShader;

    /**
     * If set, this calls gl.bindAttribLocation to bind a generic vertex index to an attribute variable. Default is
     * undefined.
     */
    public String index0AttributeName;

    /**
     * You should not change this, as it used internally for optimisation.
     * Used to check whether this or derived classes are shader materials. Default is true.
     */
    public boolean isShaderMaterial;

    /**
     * Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader. Default is false.
     */
    public boolean lights;

    /**
     * Controls wireframe thickness. Default is 1.
     * Due to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value.
     */
    public float linewidth;

    /**
     * Defines whether the material uses morphTargets; true morphTarget attributes to this shader
     */
    public boolean morphTargets;

    /**
     * Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the Geometry to the shader. Default is false.
     */
    public boolean morphNormals;

    /**
     * The compiled shader program associated with this material, generated by WebGLRenderer. You should not need to access this property.
     */
    public WebGLProgram program;

    /**
     * Define whether the material is rendered with flat shading. Default is false.
     */
    public boolean flatShading;

    /**
     * Define whether the material uses skinning; true to pass skinning attributes to the shader. Default is false.
     */
    public boolean skinning;

    /**
     * An object of the form:
     * { "uniform1": { value: 1.0 }, "uniform2": { value: 2 } } specifying the uniforms to be passed to the shader code; keys
     * are uniform names, values are definitions of the form
     * { value: 1.0 } where value is the value of the uniform. Names must match the name of the uniform, as defined in the
     * GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately
     * update the value available to the GLSL code.
     */
    public JsPropertyMap uniforms;

    /**
     * Define how the vertices are colored, by defining how the colors attribute gets populated. Possible values
     * are Constants.NoColors, Constants.FaceColors and Constants.VertexColors. Default is Constants.NoColors.
     */
    public Number vertexColors;

    /**
     * Vertex shader GLSL code. This is the actual code for the shader. In the example above, the vertexShader and fragmentShader code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead.
     */
    public String vertexShader;

    /**
     * Render geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false (i.e. render as flat
     * polygons).
     */
    public boolean wireframe;

    /**
     * Controls wireframe thickness. Default is 1.
     * Due to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value.
     */
    public float wireframeLinewidth;

    @JsConstructor
    public ShaderMaterial(ShaderMaterialParameters shaderMaterialParameters) {

    }

    @JsProperty
    public native ShaderMaterialExtensions getExtensions();

    /**
     * Generates a shallow copy of this material. Note that the vertexShader and fragmentShader are copied by reference,
     * as are the definitions of the attributes; this means that clones of the material will share the same compiled
     * WebGLProgram. However, the uniforms are copied by value, which allows you to have different sets of uniforms for
     * different copies of the material.
     *
     * @return ShaderMaterial
     */
    public native ShaderMaterial clone();


}
